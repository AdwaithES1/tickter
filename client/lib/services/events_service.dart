import 'package:supabase_flutter/supabase_flutter.dart';

import '../models/event_model.dart';

class EventsService {
  static final SupabaseClient _supabase = Supabase.instance.client;

  /// Fetch all events from the database
  static Future<List<Event>> fetchAllEvents() async {
    try {
      final response = await _supabase
          .from('events')
          .select('*')
          .order('date', ascending: true);

      return (response as List)
          .map((eventData) => Event.fromJson(eventData))
          .toList();
    } catch (error) {
      throw Exception('Failed to fetch events: ${error.toString()}');
    }
  }

  /// Fetch events for a specific date range
  static Future<List<Event>> fetchEventsForDateRange({
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      final response = await _supabase
          .from('events')
          .select('*')
          .gte('date', startDate.toIso8601String().split('T')[0])
          .lte('date', endDate.toIso8601String().split('T')[0])
          .order('date', ascending: true);

      return (response as List)
          .map((eventData) => Event.fromJson(eventData))
          .toList();
    } catch (error) {
      throw Exception(
        'Failed to fetch events for date range: ${error.toString()}',
      );
    }
  }

  /// Fetch events for a specific user based on their semester and batch
  static Future<List<Event>> fetchEventsForUser({
    required int semester,
    required int batch,
  }) async {
    try {
      final response = await _supabase
          .from('events')
          .select('*')
          .contains('semester', [semester])
          .contains('batch', [batch])
          .order('date', ascending: true);

      return (response as List)
          .map((eventData) => Event.fromJson(eventData))
          .toList();
    } catch (error) {
      throw Exception(
        'Failed to fetch user-specific events: ${error.toString()}',
      );
    }
  }

  /// Create a new event in the database
  static Future<Event> createEvent(Event event) async {
    try {
      final eventData = event.toJson();
      // Remove id and timestamps as they will be generated by the database
      eventData.remove('id');
      eventData.remove('created_at');
      eventData.remove('updated_at');

      final response = await _supabase
          .from('events')
          .insert(eventData)
          .select()
          .single();

      return Event.fromJson(response);
    } catch (error) {
      throw Exception('Failed to create event: ${error.toString()}');
    }
  }

  /// Update an existing event
  static Future<Event> updateEvent(Event event) async {
    try {
      final eventData = event.toJson();
      eventData['updated_at'] = DateTime.now().toIso8601String();

      final response = await _supabase
          .from('events')
          .update(eventData)
          .eq('id', event.id)
          .select()
          .single();

      return Event.fromJson(response);
    } catch (error) {
      throw Exception('Failed to update event: ${error.toString()}');
    }
  }

  /// Delete an event
  static Future<void> deleteEvent(String eventId) async {
    try {
      await _supabase.from('events').delete().eq('id', eventId);
    } catch (error) {
      throw Exception('Failed to delete event: ${error.toString()}');
    }
  }

  /// Group events by date
  static Map<DateTime, List<Event>> groupEventsByDate(List<Event> events) {
    final Map<DateTime, List<Event>> groupedEvents = {};

    for (final event in events) {
      final eventDate = DateTime.utc(
        event.date.year,
        event.date.month,
        event.date.day,
      );

      if (groupedEvents[eventDate] == null) {
        groupedEvents[eventDate] = [];
      }
      groupedEvents[eventDate]!.add(event);
    }

    return groupedEvents;
  }
}
